<p>You will need PHP and Laravel (5.4 or above) installed on your machine. You should have a working knowledge of PHP and JavaScript.<br/>
Realtime notifications are now very common in modern web applications, as site owners want to keep users engaged and informed of happenings on their platform. Notifications are also a great way to build addiction, and make sure users keep coming back to your platform to see "what's new".</p>

<p>With Laravel and some Pusher magic, I will be demonstrating how to build a realtime app, with desktop notifications, utilising the Notification API.</p>
<h1>Our application</h1>
<p>We will build a simple News notification module which will alert everyone on a website when a new post is published. Ideally, this would be part of a larger app, but we will build it in isolation here to showcase our desktop notifications.</p>

<p>At the end of this tutorial, you will have learned how to:</p>
<ol>
<li>Broadcast events in Laravel, using Pusher</li>
<li>Listen for events on channels, using Laravel Echo and Vue.js</li>
<li>Use the Notification API to display desktop notifications</li>
</ol>
To follow along, you will need a working knowledge of PHP and JavaScript. Basic knowledge of Laravel and Vue.js are also needed. Laravel 5.4 and Vue.js 2.3 are used.
<h2>Introduction to Pusher</h2>
Pusher is a service that makes it super easy to add realtime functionality to web and mobile applications. We will be using it in our application, so sign up to a free account here, create an app, and copy out the app credentials (App ID, Key and Secret) from the “App Keys” section.
<h2>Setup and configuration</h2>
<p>For starters, let us set up our app, and do the necessary configuration. We will call the app news-talk.<br/>
To create a new app with the Laravel installer, run this command:</p>
<pre><code>laravel new news-talk</code></pre>
The next set of commands should be run in the app's root directory.

Installing the Pusher PHP library:
<pre><code>composer require pusher/pusher-php-server</code></pre>
Installing the Laravel Frontend Dependencies (these include Bootstrap, Axios, Vue.js and a couple of other things which are <br/>nice to have):</p>
<pre><code>npm install</code></pre>
<p>Installing Laravel Echo and Pusher-js which we will use to listen for broadcast events:</p>

<pre><code>npm install -S laravel-echo pusher-js</code></pre>
<p>Next, we will do some more minor configuration to let Laravel know we will be using Pusher to manage our broadcasts.<br/>

Editing the .env:</p>
<pre><code>BROADCAST_DRIVER=pusher
PUSHER_APP_ID=your_pusher_add_id
PUSHER_APP_KEY=your_pusher_app_key
PUSHER_APP_SECRET=your_pusher_app_secret
</code></pre>
You can edit some more optional configuration for Pusher in the ./config/broadcasting.php file generated by Laravel.<br/>
Finally, we will configure Echo to use Pusher. We do that by uncommenting and editing the values at the bottom of resources/assets/js/bootstrap.js:
<pre><code>import Echo from "laravel-echo"
 window.Echo = new Echo({
     broadcaster: 'pusher',
     key: 'your_pusher_key'
});</code></pre>
<h2>Building the backend</h2>
Let's create a table for our posts. This is where data we create via our app will be persisted to. We will use a Laravel migration file, and an Eloquent model for communication with the database.<br/>

To create a Post model run this command:

<pre><code>
php artisan make:model Post -m -c
</code></pre>
The -m and c flags are for automatically generating the migration and controller files respectively.<br>

Next, we edit the generated migration file located in the ./database/migrations folder. We adjust the up method to look like this:
<pre><code>
public function up() {
  Schema::create('posts', function (Blueprint $table) {
    $table->increments('id');
    $table->string('title');
    $table->text('description');
    $table->timestamps();
  });
}
</code></pre>
Then, after editing the .env with your database details, you can create the table with this command:<br>
<pre><code>php artisan migrate</code></pre>
We should also edit the mass-assignable properties on the model:<br>
<pre><code>class Post extends Model
{

  /**
   * The attributes that are mass assignable.
   *
   * @var array
   */
  protected $fillable = ['title', 'description'];
}</code></pre>
Saving a post
Next, we will add a route and controller method to save a new post.<br>

We will be making an API call from the front-end to save our posts, so we can add the new route to the API routes at ./routes/api.php. Whatever route defined here will be prefixed by api, and belongs to the api middleware group.<br>
<pre><code>Route::post('/post', 'PostController@store');</code></pre>
Adding the corresponding controller method:<br>
<pre><code>use App\Post;

class PostController extends Controller {

  /**
   * Saves a new post to the database
   */
  public function store(Request $request) {
    // ...
    // validation can be done here before saving 
    // with $this->validate($request, $rules)
    // ...

    // get data to be saved in an associative array using $request->only()
    $data = $request->only(['title', 'description']);

    //  save post and assign return value of created post to $post array
    $post = Post::create($data);

    // return post as response, Laravel automatically serializes this to JSON
    return response($post, 201);
  }
}</code></pre>
<h2>Working with events</h2>
<p>Events are a great way to separate out application logic. We can define events to be triggered in our application when an action occurs, and we can define listeners, to listen for such events and carry out other activities.

Laravel allows for easy definition of events and listeners out of the box. It also includes helper functions and classes to allow us easily trigger and broadcast events.

We can create a new event with this command:</p>
<pre><code>php artisan make:event PostPublished</code></pre>
<p>The event class file is created at ./app/Events.<br>

We can then edit it to suit our needs:</p>
<pre><code>class PostPublished implements ShouldBroadcast {
  use Dispatchable, InteractsWithSockets, SerializesModels;

  public $post;

  public function __construct($post) {
    $this->post = $post;
  }

  /**
   * Get the channels the event should broadcast on.
   *
   * @return Channel|array
   */
  public function broadcastOn() {
    return new Channel('posts');
  }

  public function broadcastWith() {
    return [
      'title' => $this->post->title,
    ];
  }
}</code></pre>
<p>
The Illuminate\Contracts\Broadcasting\ShouldBroadcast interface on the event class is used to inform Laravel that this event should be broadcast.<br/>

The broadcastOn method returns the channel that we want to broadcast our event on. The Channel class is used for broadcasting on public channels. PrivateChannel and PresenceChannel are for private channels (these require authentication for access). You can read more about the various Pusher channels here.<br>
By default, Laravel broadcasts all of an event class’ public properties as its payload… broadcastWith helps us override that behaviour and choose what we want to send.</p>
<h2>Dispatching events</h2>
<p>In our app, we want to dispatch the PostPublished event after a post has been saved. In Laravel, we can dispatch events using the Event Facade, or the event() helper function.<br>

To dispatch our PostPublished event, we can edit the store method in the PostController, and place the event call right after the post is saved:</p>
<pre><code>use App\Events\PostPublished;

// save post and assign return value of created post to $post array
$post = Post::create($data);

// fire PostPublished event after post is successfully added to database
event(new PostPublished($post));
// or
// \Event::fire(new PostPublished($post))</code></pre>
<p>The final PostController file will look like this:</p>
<pre><code>namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Events\PostPublished;
use App\Post;

class PostController extends Controller {

  /**
   * Saves a new post to the database
   */
  public function store(Request $request) {
    // ...
    // validation can be done here before saving 
    // with $this->validate($request, $rules)
    // ...

    // get data to save in an associative array using $request->only()
    $data = $request->only(['title', 'description']);

    //  save post and assign return value of created post to $post array
    $post = Post::create($data);

    // fire PostPublished event after post is successfully added to database
    event(new PostPublished($post));
    // or
    // \Event::fire(new PostPublished($post))

    // return post as response, Laravel automatically serializes this to JSON
    return response($post, 201);
  }
}</code></pre>
<p>Now that we are done with building the backend, we can proceed to create our view and event listener on the Frontend.</p>
<h2>Building the frontend</h2>
<p>To create a basic page view for our app, we can edit the default welcome.blade.php file created by Laravel. We can replace its contents with the following:</p>
<pre><code>

&lt;!DOCTYPE html&gt;
&lt;html lang="{{ config('app.locale') }}"&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;

  &lt;!-- CSRF Token --&gt;
  &lt;meta name="csrf-token" content="{{ csrf_token() }}"&gt;

  &lt;title&gt;News Talk&lt;/title&gt;

  &lt;!-- Styles --&gt;
  &lt;link href="{{ asset('css/app.css') }}" rel="stylesheet"&gt;

  &lt;style&gt;
    .container {
      padding-top: 100px;
    }
  &lt;/style&gt;

  &lt;!-- Scripts --&gt;
  &lt;script&gt;
    window.Laravel = {!! json_encode([
      'csrfToken' =&gt; csrf_token(),
    ]) !!};
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

  &lt;div id="app"&gt;
    &lt;!-- home Vue component --&gt;
    &lt;home&gt;&lt;/home&gt;
  &lt;/div&gt;

  &lt;!-- Scripts --&gt;
  &lt;script src="{{ asset('js/app.js') }}"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>Most of the code above is boilerplate Laravel HTML content with relevant scripts and CSS files attached. We will generate them later on.<br>

We also included a Vue component (home) which hasn't been defined yet. Let us go ahead to create and define it.<br>

Creating the home Vue component:</p>
<pre><code><!-- ./resources/assets/js/components/Home.vue -->
&lt;template&gt;
  &lt;div class="container"&gt;
    &lt;div class="row"&gt;
      &lt;div class="col-sm-6 col-sm-offset-3"&gt;
        &lt;div class="form-group"&gt;
          &lt;label for="title"&gt;Post Title&lt;/label&gt;
          &lt;input v-model="newPostTitle" id="title" type="text" class="form-control"&gt;
        &lt;/div&gt;
        &lt;div class="form-group"&gt;
          &lt;label for="description"&gt;Post Description&lt;/label&gt;
          &lt;textarea v-model="newPostDesc" id="description" rows="8" class="form-control"&gt;&lt;/textarea&gt;
        &lt;/div&gt;
        &lt;button @click="addPost(newPostTitle, newPostDesc)" 
          :class="{disabled: (!newPostTitle || !newPostDesc)}"
          class="btn btn-block btn-primary"&gt;Submit&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        newPostTitle: "", 
        newPostDesc: "" 
      }
    },
    created() {
      this.listenForChanges();
    },
    methods: {
      addPost(postName, postDesc) {
        // check if entries are not empty
        if(!postName || !postDesc)
          return;

        // make API to save post
        axios.post('/api/post', {
          title: postName, description: postDesc
        }).then( response =&gt; {
          if(response.data) { 
            this.newPostTitle = this.newPostDesc = "";
          }
        })
      },
      listenForChanges() {
        Echo.channel('posts')
          .listen('PostPublished', post =&gt; {
            if (! ('Notification' in window)) {
              alert('Web Notification is not supported');
              return;
            }

            Notification.requestPermission( permission =&gt; {
              let notification = new Notification('New post alert!', {
                body: post.title, // content for the alert
                icon: "https://pusher.com/static_logos/320x320.png" // optional image url
              });

              // link to page on clicking the notification
              notification.onclick = () =&gt; {
                window.open(window.location.href);
              };
            });
          })
        }
      } 
    }
&lt;/script&gt;
</code></pre>
<p>In the above code, we define two methods. addPost() and listenForChanges. The addPost method makes a post request to our API with the required payload when a user adds a new post.<br>

In the listenForChanges method, we use Echo to subscribe to the posts channel, which is the channel we are broadcasting to, from our backend. We also listen for PostPublished events, and define a callback that activates our desktop notification whenever an event is fired.<br>

We are using the notifications API for desktop notifications. We first request permission to send desktop notifications, then notify the user once permission is granted.<br>

We can also check if a browser supports desktop notifications this way:</p>
<pre><code>if (window.Notification) {
    console.log('Notifications are supported!');
} else {
    alert('Notifications aren\'t supported on your browser! :(');
}</code></pre>
<p>We create an instance of the Notification object with our post title as the body. An optional icon parameter can also be set, as we did.<br>

Finally, we define the component as a global component in app.js:</p>
<pre><code>Vue.component('home', require('./components/Home.vue'));</code></pre>
<h2>Bringing it all together</h2>
We can compile our assets easily using Laravel Mix!:
<pre><code>npm run dev</code></pre>